% !TeX spellcheck = es_ES
%\documentclass[11pt,oneside, draft]{book}
\documentclass[oneside]{article}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{multicol}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[a4paper]{geometry}
\usepackage[latin1]{inputenc}
\usepackage{alltt}
\usepackage{fancyvrb} %Enhaced verbatim environments
\usepackage{url}
\usepackage{xspace}
\usepackage{underscore}
\usepackage[pstricks1-10]{vaucanson-g}
\usepackage[nomargin,inline,index]{fixme}
\usepackage{subfigure}
\usepackage{fixme}
%\renewcommand\bibname{Bibliografía}
%\newcommand{\isRefinedBy}{\preceq}
\usepackage{natbib}
\setlength{\bibsep}{0.0pt}
\setlength{\parindent}{1cm}

	\title{Programs Synthesis Roadmap}
    \author{Leandro E. Nahabedian}
\date{ }

\begin{document}
\maketitle
%\newpage
%
%\tableofcontents
%\newpage


\section{Introduction}

\paragraph{Programs synthesis}
%Synthesis what and why they are trendy
Program synthesis is the systematic derivation of a program from a given specification. For this reason,
over the years, different formalisms to represent the specifications were presented. Each of them shows a large variety
of strengths and weaknesses, making the area of programs synthesis a controversial one. Probably, the most common way to
write specifications is by using logics expressing, in a declarative manner, the goals of the system to be
synthesised. For instance, in \cite{1985, ConcurrentAndTemporalLogic1, ConcurrentAndTemporalLogic2}, the authors used
temporal logic to defined the specifications. Building software automatically showed many advantages in contrast to
building them manually, attracting researchers to produce new program synthesis techniques until now.

% Advantages
The main strength of synthesis techniques are the absence of human mistakes that a
programmer introduce to a code while working. Resulting software generated by synthesis are correct in terms of the
requirements as it is built avoiding violations on the given requirements. The \textit{correct by construction}
philosophy is used in both controllers synthesis problems, as in \cite{inverardi09, pnueli89a, dippolito10} and also, in
code synthesis problems, as in \cite{foster1, SKETCH}. 

On the other hand, producing concurrent programs are a challenging task for a programmer because interleaving executions
must be taken into account. Many advantages of making programs by synthesis in concurrent domains, are presented in
\cite{Concurrent, ConcurrentAndTemporalLogic1, ConcurrentAndTemporalLogic2} where in \cite{Concurrent} the authors proposed to map high-level
requirements as a supervisory control specification. However, in \cite{ConcurrentAndTemporalLogic1,
ConcurrentAndTemporalLogic2}, temporal logics are used.



\paragraph{Controllers synthesis}

This roadmap is strongly connected with techniques that builds automatically behaviour strategies. For example, we can
identify different areas similar to programs synthesis, like model-driven development in \cite{giese12}, planning in
\cite{universal,bertoli01,seams08}, supervisory control in \cite{980826} and controller synthesis in \cite{piterman06}

Controller synthesis area started with the paper of B\"uchi, Landweber, and Rabin in \cite{buchi69} and its evolution to
modern techniques \cite{Pnueli:1989:SRM:75277.75293}. The general problem of synthesis is computationally expensive, but
recently works tries to tackle it by defying sub-logics which allows handling more restrictive specifications with
polynomial complexity (i.e. \cite{piterman06,Kupferman:2005:SDP:1097112.1097487}).
Originally, research community has been focused in embedded systems and digital circuits, leading synthesis to other
domains such as communications through shared memory and concurrency.
However, in areas like requirements engineering, architectural design, and concurrency, a communication through messages
model are more appropriate, and more recently, synthesis of behavioural models based in events had been explored.
\cite{dippolito10}


\section{Background}

The beginning of the programs synthesis has its origin 30 years ago, with \cite{1970, 1985, 1980}. 
%Indicar el marco teórico de la investigación y las hipótesis de trabajo propuestas 
%consignando, sobre qué otros trabajos de investigación propios o de contribuciones de  
%terceros, se basan. 

At the beginning, \cite{1985}, use a special Logic to define the requirements, called Linear Temporal Logic (LTL). 


\section{Discussion}

%Problems to achieve synthesis
In spite of the benefits of the synthesis technique introduced before, we have to pay an expensive price for this. 

% Declarative or imperative?

% Things to be done

\subsection{Controllers Synthesis vs Programs Synthesis }





\small{
\bibliographystyle{abbrv}
\bibliography{AAP.bib}
}

%\end{multicols}


\end{document}
